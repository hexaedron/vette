#include "ch32v003fun.h"

#include "include/FSM.h"
#include "include/ALDL_cmd.h"
#include "include/UART.h"

extern const char vette_version[];

tim2Encoder enc(AFIO_PCFR1_TIM2_REMAP_NOREMAP);
sh1106 OLEDScreen;
UART ALDL_UART;
A172ALDL ALDLData = {0};
ABSALDL ABSData   = {0};
ALDLParser myALDLParser;

// https://menginventor.github.io/FSM_coder/#


// This section generated by FSM Coder
void ( *fsm_state )( void ); // use function pointer as state variable;
bool fsm_enter_state_flag = true;

void fsm_init()
{
	fsm_state = &fsm_init_state;
}

void fsm_update()
{
	keyTick();
	( *fsm_state )(); // call FSM state
}

// ****************************************************************************************

void fsm_init_state()
{
	// Declare local/static variable here.

	if ( fsm_enter_state_flag )
	{
		// Run once when enter this state.
        ALDL_UART.beginHD(8192);

        OLEDScreen.init();
        makeStartScreen();
        OLEDScreen.refresh();

		// Prepare parser. We ned to attach only once.
		myALDLParser.attach(&ALDLData);
	}
	
	// Run repeatly for update.

	// Version info etc.
	int8_t delta = enc.getDelta();
	if( delta != 0 )
	{
		makeVersionScreen();
	}


	if ( btnClick() )
	{
		fsm_state = &fsm_selectMode_state;
		fsm_enter_state_flag = true;
		return;
	}

	fsm_enter_state_flag = false; // Reset flag
}

// ****************************************************************************************

void getADLDData(void)
{
	memset(&ALDLData, 0, sizeof(ALDLData));
	ALDLData.checksum = 0xFF; // To make the all-zeroes ALDLData invalid
	
	// Here we get ALDL data
	ENABLE_UART_WRITE();

		#ifdef NEED_SILENT_MODE
			ALDL_UART.write(silentModeCmd, sizeof(silentModeCmd));
			DISABLE_UART_WRITE();
			Delay_Ms(SILENT_MESSAGE_MS);	
			ENABLE_UART_WRITE();
			ALDL_UART.write(silentModeCCMCmd, sizeof(silentModeCCMCmd)); // Set silent mode
			DISABLE_UART_WRITE();
			Delay_Ms(SILENT_MESSAGE_MS);
			ENABLE_UART_WRITE();
		#endif

		ALDL_UART.write(getECMDataCmd, sizeof(getECMDataCmd));
		// Flush first to ensure there is nothing left in buffer
		ALDL_UART.flush();
	DISABLE_UART_WRITE();

	// wait to ensure we get all the data
	Delay_Ms(ALDL_MESSAGE_MS);

	#ifndef ECM_DEBUG
		ALDL_UART.fillBuff((uint8_t*)&ALDLData, sizeof(ALDLData));
	#endif

	Delay_Ms(ALDL_POLL_MS - SILENT_MESSAGE_MS - ALDL_MESSAGE_MS);
}

// ****************************************************************************************

void flushADLDErrors()
{
	// Here we clear ALDL errors
	ENABLE_UART_WRITE();
		ALDL_UART.write(clearCodesCmd, sizeof(clearCodesCmd));
	DISABLE_UART_WRITE();

	// wait
	Delay_Ms(ALDL_POLL_MS);
}

// ****************************************************************************************

void getABSData(void)
{
	memset(&ABSData, 0, sizeof(ABSData));

	// Here we get ALDL data
	ENABLE_UART_WRITE();
		ALDL_UART.write(silentModeCmd, sizeof(silentModeCmd)); // Set silent mode
	DISABLE_UART_WRITE();

	Delay_Ms(ABS_SILENT_MESSAGE_MS);	

	ENABLE_UART_WRITE();
		ALDL_UART.write(silentModeCCMCmd, sizeof(silentModeCCMCmd)); // Set silent mode
	DISABLE_UART_WRITE();

	Delay_Ms(ABS_SILENT_MESSAGE_MS);

	ENABLE_UART_WRITE();
		ALDL_UART.write(getABSDataCmd, sizeof(getABSDataCmd)); // Get data
		ALDL_UART.flush();
	DISABLE_UART_WRITE();

	// wait to ensure we get all the data
	Delay_Ms(ABS_MESSAGE_MS);

	#ifndef ECM_DEBUG
		ALDL_UART.fillBuff((uint8_t*)&ABSData, sizeof(ABSData));
	#endif

	// Return to normal mode
	ENABLE_UART_WRITE();
		ALDL_UART.write(returnFromABSCmd, sizeof(returnFromABSCmd));
	DISABLE_UART_WRITE();

	Delay_Ms(ALDL_POLL_MS - ABS_MESSAGE_MS - ABS_SILENT_MESSAGE_MS * 2);
}

// ****************************************************************************************

void makeScreen(uint8_t x, uint8_t y, const unsigned char *input, uint8_t width, uint8_t height)
{
	OLEDScreen.setbuf(0);
	OLEDScreen.drawFrame(1);
	if((int)input != 0)
		OLEDScreen.drawImage(x, y, input, width, height, 0);
}

// ****************************************************************************************

void makeStartScreen(void)
{
	OLEDScreen.drawImage(10, 1, vette_logo, 88, 64, 0);
    OLEDScreen.drawchar(6, 15, 'P', 1);
    OLEDScreen.drawchar(6, 25, 'r', 1);
    OLEDScreen.drawchar(6, 35, 'e', 1);
    OLEDScreen.drawchar(6, 45, 's', 1);
    OLEDScreen.drawchar(6, 55, 's', 1);

    OLEDScreen.drawchar(116, lineNumbers[0], 'B', 1);
    OLEDScreen.drawchar(116, lineNumbers[1], 'u', 1);
    OLEDScreen.drawchar(116, lineNumbers[2], 't', 1);
    OLEDScreen.drawchar(116, lineNumbers[3], 't', 1);
    OLEDScreen.drawchar(116, lineNumbers[4], 'o', 1);
    OLEDScreen.drawchar(116, lineNumbers[5], 'n', 1);
    OLEDScreen.drawFrame(1);
}

// ****************************************************************************************

void makeVersionScreen(void)
{
	// Clear screen
	OLEDScreen.setbuf(0);
	OLEDScreen.drawFrame(1);

	//OLEDScreen.drawstr(4,  lineNumbers[1] - 4, (char*)"Version:",    1);
	//OLEDScreen.drawstr(56, lineNumbers[1] - 4, (char*)vette_version, 1);
	//OLEDScreen.drawstr(4,  lineNumbers[3] - 4, (char*)"Date:",       1);
	//OLEDScreen.drawstr(46, lineNumbers[3] - 4, (char*)__DATE__,      1);
	//OLEDScreen.drawstr(4,  lineNumbers[5] - 4, (char*)"GCC",         1);

	//char gcc_ver[10];
	//char buf[4];
	//itoa(__GNUC__, gcc_ver, 10);
	//strcat(gcc_ver, ".");
	//itoa(__GNUC_MINOR__, buf, 10);
	//strcat(gcc_ver, buf);
	//strcat(gcc_ver, ".");
	//itoa(__GNUC_PATCHLEVEL__, buf, 10);
	//strcat(gcc_ver, buf);

	//OLEDScreen.drawstr(30, lineNumbers[5] - 4, gcc_ver,      1);


	OLEDScreen.drawstr(4,  lineNumbers[0], (char*)"Version:",    1);
	OLEDScreen.drawstr(56, lineNumbers[0], (char*)vette_version, 1);
	OLEDScreen.drawstr(4,  lineNumbers[1], (char*)"Date:",       1);
	OLEDScreen.drawstr(46, lineNumbers[1], (char*)__DATE__,      1);
	OLEDScreen.drawstr(4,  lineNumbers[2], (char*)"GCC",         1);

	char gcc_ver[10];
	char buf[9];
	itoa(__GNUC__, gcc_ver, 10);
	strcat(gcc_ver, ".");
	itoa(__GNUC_MINOR__, buf, 10);
	strcat(gcc_ver, buf);
	strcat(gcc_ver, ".");
	itoa(__GNUC_PATCHLEVEL__, buf, 10);
	strcat(gcc_ver, buf);

	OLEDScreen.drawstr(30, lineNumbers[2], gcc_ver,      1);

	OLEDScreen.drawstr(4,  lineNumbers[4] - 4, (char*)"ID:", 1);
	itoa(ESIG->UID0, buf,  16);
	OLEDScreen.drawstr(4,  lineNumbers[5] - 4, buf, 1);
	itoa(ESIG->UID1, buf,  16);
	OLEDScreen.drawstr(52, lineNumbers[5] - 4, buf, 1);

	OLEDScreen.refresh();
}

// ****************************************************************************************

void CLS(void)
{
	OLEDScreen.fillRect(2, 4, 125, 58, 0);
}

// ****************************************************************************************